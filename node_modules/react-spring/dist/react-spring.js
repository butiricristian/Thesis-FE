'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _objectSpread = _interopDefault(require('@babel/runtime/helpers/builtin/objectSpread'));
var _inheritsLoose = _interopDefault(require('@babel/runtime/helpers/builtin/inheritsLoose'));
var normalizeColor = _interopDefault(require('normalize-css-color'));
var _extends = _interopDefault(require('@babel/runtime/helpers/builtin/extends'));
var _objectWithoutProperties = _interopDefault(require('@babel/runtime/helpers/builtin/objectWithoutProperties'));
var React = _interopDefault(require('react'));
var ReactDOM = _interopDefault(require('react-dom'));
var _assertThisInitialized = _interopDefault(require('@babel/runtime/helpers/builtin/assertThisInitialized'));
var createContext = _interopDefault(require('create-react-context'));

// Important note: start() and stop() will only be called at most once.
// Once an animation has been stopped or finished its course, it will
// not be reused.
var Animation =
/*#__PURE__*/
function () {
  function Animation() {}

  var _proto = Animation.prototype;

  _proto.start = function start(fromValue, onUpdate, onEnd, previousAnimation) {};

  _proto.stop = function stop() {}; // Helper function for subclasses to make sure onEnd is only called once.


  _proto.__debouncedOnEnd = function __debouncedOnEnd(result) {
    var onEnd = this.__onEnd;
    this.__onEnd = null;
    onEnd && onEnd(result);
  };

  return Animation;
}();

var Animated =
/*#__PURE__*/
function () {
  function Animated() {}

  var _proto = Animated.prototype;

  _proto.__attach = function __attach() {};

  _proto.__detach = function __detach() {};

  _proto.__getValue = function __getValue() {};

  _proto.__getAnimatedValue = function __getAnimatedValue() {
    return this.__getValue();
  };

  _proto.__addChild = function __addChild(child) {};

  _proto.__removeChild = function __removeChild(child) {};

  _proto.__getChildren = function __getChildren() {
    return [];
  };

  return Animated;
}();

var AnimatedTracking =
/*#__PURE__*/
function (_Animated) {
  _inheritsLoose(AnimatedTracking, _Animated);

  function AnimatedTracking(value, parent, animationClass, animationConfig, callback) {
    var _this;

    _this = _Animated.call(this) || this;
    _this._value = value;
    _this._parent = parent;
    _this._animationClass = animationClass;
    _this._animationConfig = animationConfig;
    _this._callback = callback;

    _this.__attach();

    _this._hey = 1;
    return _this;
  }

  var _proto = AnimatedTracking.prototype;

  _proto.__getValue = function __getValue() {
    return this._parent.__getValue();
  };

  _proto.__attach = function __attach() {
    this._parent.__addChild(this);
  };

  _proto.__detach = function __detach() {
    this._parent.__removeChild(this);
  };

  _proto.update = function update() {
    this._value.animate(new this._animationClass(_objectSpread({}, this._animationConfig, {
      toValue: this._animationConfig.toValue.__getValue()
    })), this._callback);
  };

  return AnimatedTracking;
}(Animated);

var AnimatedWithChildren =
/*#__PURE__*/
function (_Animated) {
  _inheritsLoose(AnimatedWithChildren, _Animated);

  function AnimatedWithChildren() {
    var _this;

    _this = _Animated.call(this) || this;
    _this._children = [];
    return _this;
  }

  var _proto = AnimatedWithChildren.prototype;

  _proto.__addChild = function __addChild(child) {
    if (child instanceof AnimatedTracking) this._tracked = true;
    if (this._children.length === 0) this.__attach();

    this._children.push(child);
  };

  _proto.__removeChild = function __removeChild(child) {
    var index = this._children.indexOf(child);

    if (index === -1) {
      console.warn("Trying to remove a child that doesn't exist");
      return;
    }

    this._children.splice(index, 1);

    if (this._children.length === 0) this.__detach();
  };

  _proto.__getChildren = function __getChildren() {
    return this._children;
  };

  return AnimatedWithChildren;
}(Animated);

var linear = function linear(t) {
  return t;
};
/**
 * Very handy helper to map input ranges to output ranges with an easing
 * function and custom behavior outside of the ranges.
 */


var Interpolation =
/*#__PURE__*/
function () {
  function Interpolation() {}

  Interpolation.create = function create(config) {
    if (typeof config === 'function') return function () {
      return config.apply(void 0, arguments);
    };
    if (config.output && typeof config.output[0] === 'string') return createInterpolationFromStringOutputRange(config);
    var outputRange = config.output;
    var inputRange = config.range;
    var easing = config.easing || linear;
    var extrapolateLeft = 'extend';

    if (config.extrapolateLeft !== undefined) {
      extrapolateLeft = config.extrapolateLeft;
    } else if (config.extrapolate !== undefined) {
      extrapolateLeft = config.extrapolate;
    }

    var extrapolateRight = 'extend';

    if (config.extrapolateRight !== undefined) {
      extrapolateRight = config.extrapolateRight;
    } else if (config.extrapolate !== undefined) {
      extrapolateRight = config.extrapolate;
    }

    return function (input) {
      var range = findRange(input, inputRange);
      return interpolate(input, inputRange[range], inputRange[range + 1], outputRange[range], outputRange[range + 1], easing, extrapolateLeft, extrapolateRight);
    };
  };

  return Interpolation;
}();

function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight) {
  var result = input; // Extrapolate

  if (result < inputMin) {
    if (extrapolateLeft === 'identity') {
      return result;
    } else if (extrapolateLeft === 'clamp') {
      result = inputMin;
    } else if (extrapolateLeft === 'extend') {// noop
    }
  }

  if (result > inputMax) {
    if (extrapolateRight === 'identity') {
      return result;
    } else if (extrapolateRight === 'clamp') {
      result = inputMax;
    } else if (extrapolateRight === 'extend') {// noop
    }
  }

  if (outputMin === outputMax) return outputMin;

  if (inputMin === inputMax) {
    if (input <= inputMin) return outputMin;
    return outputMax;
  } // Input Range


  if (inputMin === -Infinity) {
    result = -result;
  } else if (inputMax === Infinity) {
    result = result - inputMin;
  } else {
    result = (result - inputMin) / (inputMax - inputMin);
  } // Easing


  result = easing(result); // Output Range

  if (outputMin === -Infinity) {
    result = -result;
  } else if (outputMax === Infinity) {
    result = result + outputMin;
  } else {
    result = result * (outputMax - outputMin) + outputMin;
  }

  return result;
}

function colorToRgba(input) {
  var int32Color = normalizeColor(input);
  if (int32Color === null) return input;
  int32Color = int32Color || 0; // $FlowIssue

  var r = (int32Color & 0xff000000) >>> 24;
  var g = (int32Color & 0x00ff0000) >>> 16;
  var b = (int32Color & 0x0000ff00) >>> 8;
  var a = (int32Color & 0x000000ff) / 255;
  return "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
}

var stringShapeRegex = /[0-9\.-]+/g;
/**
 * Supports string shapes by extracting numbers so new values can be computed,
 * and recombines those values into new strings of the same shape.  Supports
 * things like:
 *
 *   rgba(123, 42, 99, 0.36) // colors
 *   -45deg                  // values with units
 */

function createInterpolationFromStringOutputRange(config) {
  var outputRange = config.output;
  outputRange = outputRange.map(colorToRgba); // ->
  // [
  //   [0, 50],
  //   [100, 150],
  //   [200, 250],
  //   [0, 0.5],
  // ]

  /* $FlowFixMe(>=0.18.0): `outputRange[0].match()` can return `null`. Need to
   * guard against this possibility.
   */

  var outputRanges = outputRange[0].match(stringShapeRegex).map(function () {
    return [];
  });
  outputRange.forEach(function (value) {
    /* $FlowFixMe(>=0.18.0): `value.match()` can return `null`. Need to guard
     * against this possibility.
     */
    value.match(stringShapeRegex).forEach(function (number, i) {
      return outputRanges[i].push(+number);
    });
  });
  /* $FlowFixMe(>=0.18.0): `outputRange[0].match()` can return `null`. Need to
     * guard against this possibility.
     */

  var interpolations = outputRange[0].match(stringShapeRegex).map(function (value, i) {
    return Interpolation.create(_objectSpread({}, config, {
      output: outputRanges[i]
    }));
  }); // rgba requires that the r,g,b are integers.... so we want to round them, but we *dont* want to
  // round the opacity (4th column).

  var shouldRound = /^rgb/.test(outputRange[0]);
  return function (input) {
    var i = 0; // 'rgba(0, 100, 200, 0)'
    // ->
    // 'rgba(${interpolations[0](input)}, ${interpolations[1](input)}, ...'

    return outputRange[0].replace(stringShapeRegex, function () {
      var val = interpolations[i++](input);
      return String(shouldRound && i < 4 ? Math.round(val) : val);
    });
  };
}

function findRange(input, inputRange) {
  for (var i = 1; i < inputRange.length - 1; ++i) {
    if (inputRange[i] >= input) break;
  }

  return i - 1;
}

var AnimatedInterpolation =
/*#__PURE__*/
function (_AnimatedWithChildren) {
  _inheritsLoose(AnimatedInterpolation, _AnimatedWithChildren);

  function AnimatedInterpolation(parents, config) {
    var _this;

    _this = _AnimatedWithChildren.call(this) || this;
    _this._parents = Array.isArray(parents) ? parents : [parents];
    _this._interpolation = Interpolation.create(config);
    return _this;
  }

  var _proto = AnimatedInterpolation.prototype;

  _proto.__getValue = function __getValue() {
    return this._interpolation.apply(this, this._parents.map(function (value) {
      return value.__getValue();
    }));
  };

  _proto.__attach = function __attach() {
    for (var i = 0; i < this._parents.length; ++i) {
      if (this._parents[i] instanceof Animated) this._parents[i].__addChild(this);
    }
  };

  _proto.__detach = function __detach() {
    for (var i = 0; i < this._parents.length; ++i) {
      if (this._parents[i] instanceof Animated) this._parents[i].__removeChild(this);
    }
  };

  _proto.interpolate = function interpolate(config) {
    return new AnimatedInterpolation(this, config);
  };

  return AnimatedInterpolation;
}(AnimatedWithChildren);

var _uniqueId = 0;
/**
 * Animated works by building a directed acyclic graph of dependencies
 * transparently when you render your Animated components.
 *
 *               new Animated.Value(0)
 *     .interpolate()        .interpolate()    new Animated.Value(1)
 *         opacity               translateY      scale
 *          style                         transform
 *         View#234                         style
 *                                         View#123
 *
 * A) Top Down phase
 * When an Animated.Value is updated, we recursively go down through this
 * graph in order to find leaf nodes: the views that we flag as needing
 * an update.
 *
 * B) Bottom Up phase
 * When a view is flagged as needing an update, we recursively go back up
 * in order to build the new value that it needs. The reason why we need
 * this two-phases process is to deal with composite props such as
 * transform which can receive values from multiple parents.
 */

function findAnimatedStyles(node, styles) {
  if (typeof node.update === 'function') styles.add(node);else node.__getChildren().forEach(function (child) {
    return findAnimatedStyles(child, styles);
  });
}
/**
 * Standard value for driving animations.  One `Animated.Value` can drive
 * multiple properties in a synchronized fashion, but can only be driven by one
 * mechanism at a time.  Using a new mechanism (e.g. starting a new animation,
 * or calling `setValue`) will stop any previous ones.
 */


var AnimatedValue =
/*#__PURE__*/
function (_AnimatedWithChildren) {
  _inheritsLoose(AnimatedValue, _AnimatedWithChildren);

  function AnimatedValue(value) {
    var _this;

    _this = _AnimatedWithChildren.call(this) || this;
    _this._value = value;
    _this._animation = null;
    _this._animatedStyles = new Set();
    _this._listeners = {};
    return _this;
  }

  var _proto = AnimatedValue.prototype;

  _proto.__detach = function __detach() {
    this.stopAnimation();
  };

  _proto.__getValue = function __getValue() {
    return this._value;
  };

  _proto._flush = function _flush() {
    //if (this._animatedStyles.size === 0 || this._tracked) this._update()
    findAnimatedStyles(this, this._animatedStyles);

    this._animatedStyles.forEach(function (animatedStyle) {
      return animatedStyle.update();
    });
  };

  _proto._updateValue = function _updateValue(value) {
    this._value = value;

    this._flush();

    for (var key in this._listeners) {
      this._listeners[key]({
        value: this.__getValue()
      });
    }
  };
  /**
   * Directly set the value.  This will stop any animations running on the value
   * and update all the bound properties.
   */


  _proto.setValue = function setValue(value) {
    if (this._animation) {
      this._animation.stop();

      this._animation = null;
    }

    this._animatedStyles.clear();

    this._updateValue(value);
  };
  /**
   * Stops any running animation or tracking.  `callback` is invoked with the
   * final value after stopping the animation, which is useful for updating
   * state to match the animation position with layout.
   */


  _proto.stopAnimation = function stopAnimation(callback) {
    this.stopTracking();
    this._animation && this._animation.stop();
    this._animation = null;
    callback && callback(this.__getValue());
  };
  /**
   * Interpolates the value before updating the property, e.g. mapping 0-1 to
   * 0-10.
   */


  _proto.interpolate = function interpolate(config) {
    return new AnimatedInterpolation(this, config);
  };
  /**
   * Typically only used internally, but could be used by a custom Animation
   * class.
   */


  _proto.animate = function animate(animation, callback) {
    var _this2 = this;

    var previousAnimation = this._animation;
    this._animation && this._animation.stop();
    this._animation = animation;

    this._animatedStyles.clear();

    animation.start(this._value, function (value) {
      return _this2._updateValue(value);
    }, function (result) {
      _this2._animation = null;
      callback && callback(result);
    }, previousAnimation);
  };
  /**
   * Adds an asynchronous listener to the value so you can observe updates from
   * animations.  This is useful because there is no way to
   * synchronously read the value because it might be driven natively.
   */


  _proto.addListener = function addListener(callback) {
    var id = String(_uniqueId++);
    this._listeners[id] = callback;
    return id;
  };

  _proto.removeListener = function removeListener(id) {
    delete this._listeners[id];
  };

  _proto.removeAllListeners = function removeAllListeners() {
    this._listeners = {};
  };
  /**
   * Typically only used internally.
   */


  _proto.stopTracking = function stopTracking() {
    this._tracking && this._tracking.__detach();
    this._tracking = null;
  };
  /**
   * Typically only used internally.
   */


  _proto.track = function track(tracking) {
    this.stopTracking();
    this._tracking = tracking;
  };

  return AnimatedValue;
}(AnimatedWithChildren);

var AnimatedArray =
/*#__PURE__*/
function (_AnimatedWithChildren) {
  _inheritsLoose(AnimatedArray, _AnimatedWithChildren);

  function AnimatedArray(array) {
    var _this;

    _this = _AnimatedWithChildren.call(this) || this;
    _this._values = array.map(function (n) {
      return new AnimatedValue(n);
    });
    return _this;
  }

  var _proto = AnimatedArray.prototype;

  _proto.setValue = function setValue(values) {
    var _this2 = this;

    values.forEach(function (n, i) {
      return _this2._values[i].setValue(n);
    });
  };

  _proto.__getValue = function __getValue() {
    return this._values.map(function (v) {
      return v.__getValue();
    });
  };

  _proto.stopAnimation = function stopAnimation(callback) {
    this._values.forEach(function (v) {
      return v.stopAnimation();
    });

    callback && callback(this.__getValue());
  };

  _proto.__attach = function __attach() {
    for (var i = 0; i < this._values.length; ++i) {
      if (this._values[i] instanceof Animated) this._values[i].__addChild(this);
    }
  };

  _proto.__detach = function __detach() {
    for (var i = 0; i < this._values.length; ++i) {
      if (this._values[i] instanceof Animated) this._values[i].__removeChild(this);
    }
  };

  return AnimatedArray;
}(AnimatedWithChildren);

var AnimatedTemplate =
/*#__PURE__*/
function (_AnimatedWithChildren) {
  _inheritsLoose(AnimatedTemplate, _AnimatedWithChildren);

  function AnimatedTemplate(strings, values) {
    var _this;

    _this = _AnimatedWithChildren.call(this) || this;
    _this._strings = strings;
    _this._values = values;
    console.warn('OBSOLETE: templates in react-spring will be superceded by interpolators in the next minor, so that template`${radius}deg` becomes: radius.interpolate(r => `${r}deg` or for multiple values: interpolate([x,y,z], (x,y,z) => `${x}px,${y}px,${z}px`)');
    return _this;
  }

  var _proto = AnimatedTemplate.prototype;

  _proto.__transformValue = function __transformValue(value) {
    if (value instanceof Animated) return value.__getValue();else return value;
  };

  _proto.__getValue = function __getValue() {
    var value = this._strings[0];

    for (var i = 0; i < this._values.length; ++i) {
      value += this.__transformValue(this._values[i]) + this._strings[1 + i];
    }

    return value;
  };

  _proto.__attach = function __attach() {
    for (var i = 0; i < this._values.length; ++i) {
      if (this._values[i] instanceof Animated) this._values[i].__addChild(this);
    }
  };

  _proto.__detach = function __detach() {
    for (var i = 0; i < this._values.length; ++i) {
      if (this._values[i] instanceof Animated) this._values[i].__removeChild(this);
    }
  };

  return AnimatedTemplate;
}(AnimatedWithChildren);

var withDefault = function withDefault(value, defaultValue) {
  return value === undefined || value === null ? defaultValue : value;
};

var tensionFromOrigamiValue = function tensionFromOrigamiValue(oValue) {
  return (oValue - 30) * 3.62 + 194;
};

var frictionFromOrigamiValue = function frictionFromOrigamiValue(oValue) {
  return (oValue - 8) * 3 + 25;
};

var fromOrigamiTensionAndFriction = function fromOrigamiTensionAndFriction(tension, friction) {
  return {
    tension: tensionFromOrigamiValue(tension),
    friction: frictionFromOrigamiValue(friction)
  };
};

var SpringAnimation =
/*#__PURE__*/
function (_Animation) {
  _inheritsLoose(SpringAnimation, _Animation);

  function SpringAnimation(config) {
    var _this;

    _this = _Animation.call(this) || this;

    _this.onUpdate = function () {
      var position = _this._lastPosition;
      var velocity = _this._lastVelocity;
      var tempPosition = _this._lastPosition;
      var tempVelocity = _this._lastVelocity; // If for some reason we lost a lot of frames (e.g. process large payload or
      // stopped in the debugger), we only advance by 4 frames worth of
      // computation and will continue on the next frame. It's better to have it
      // running at faster speed than jumping to the end.

      var MAX_STEPS = 64;
      var now = Date.now();
      if (now > _this._lastTime + MAX_STEPS) now = _this._lastTime + MAX_STEPS; // We are using a fixed time step and a maximum number of iterations.
      // The following post provides a lot of thoughts into how to build this
      // loop: http://gafferongames.com/game-physics/fix-your-timestep/

      var TIMESTEP_MSEC = 1;
      var numSteps = Math.floor((now - _this._lastTime) / TIMESTEP_MSEC);

      for (var i = 0; i < numSteps; ++i) {
        // Velocity is based on seconds instead of milliseconds
        var step = TIMESTEP_MSEC / 1000; // This is using RK4. A good blog post to understand how it works:
        // http://gafferongames.com/game-physics/integration-basics/

        var aVelocity = velocity;
        var aAcceleration = _this._tension * (_this._toValue - tempPosition) - _this._friction * tempVelocity;
        var tempPosition = position + aVelocity * step / 2;
        var tempVelocity = velocity + aAcceleration * step / 2;
        var bVelocity = tempVelocity;
        var bAcceleration = _this._tension * (_this._toValue - tempPosition) - _this._friction * tempVelocity;
        tempPosition = position + bVelocity * step / 2;
        tempVelocity = velocity + bAcceleration * step / 2;
        var cVelocity = tempVelocity;
        var cAcceleration = _this._tension * (_this._toValue - tempPosition) - _this._friction * tempVelocity;
        tempPosition = position + cVelocity * step / 2;
        tempVelocity = velocity + cAcceleration * step / 2;
        var dVelocity = tempVelocity;
        var dAcceleration = _this._tension * (_this._toValue - tempPosition) - _this._friction * tempVelocity;
        tempPosition = position + cVelocity * step / 2;
        tempVelocity = velocity + cAcceleration * step / 2;
        var dxdt = (aVelocity + 2 * (bVelocity + cVelocity) + dVelocity) / 6;
        var dvdt = (aAcceleration + 2 * (bAcceleration + cAcceleration) + dAcceleration) / 6;
        position += dxdt * step;
        velocity += dvdt * step;
      }

      _this._lastTime = now;
      _this._lastPosition = position;
      _this._lastVelocity = velocity;

      _this._onUpdate(position); // a listener might have stopped us in _onUpdate


      if (!_this.__active) return; // Conditions for stopping the spring animation

      var isOvershooting = false;

      if (_this._overshootClamping && _this._tension !== 0) {
        if (_this._startPosition < _this._toValue) {
          isOvershooting = position > _this._toValue;
        } else {
          isOvershooting = position < _this._toValue;
        }
      }

      var isVelocity = Math.abs(velocity) <= _this._restSpeedThreshold;

      var isDisplacement = true;
      if (_this._tension !== 0) isDisplacement = Math.abs(_this._toValue - position) <= _this._restDisplacementThreshold;

      if (isOvershooting || isVelocity && isDisplacement) {
        // Ensure that we end up with a round value
        if (_this._tension !== 0) _this._onUpdate(_this._toValue);

        _this.__debouncedOnEnd({
          finished: true
        });

        return;
      }

      _this._animationFrame = requestAnimationFrame(_this.onUpdate);
    };

    _this._overshootClamping = withDefault(config.overshootClamping, false);
    _this._restDisplacementThreshold = withDefault(config.restDisplacementThreshold, 0.001);
    _this._restSpeedThreshold = withDefault(config.restSpeedThreshold, 0.001);
    _this._initialVelocity = config.velocity;
    _this._lastVelocity = withDefault(config.velocity, 0);
    _this._toValue = config.toValue;
    _this.__isInteraction = config.isInteraction !== undefined ? config.isInteraction : true;
    var springConfig = fromOrigamiTensionAndFriction(withDefault(config.tension, 40), withDefault(config.friction, 7));
    _this._tension = springConfig.tension;
    _this._friction = springConfig.friction;
    _this._delay = config.delay !== undefined ? config.delay : 0;
    return _this;
  }

  var _proto = SpringAnimation.prototype;

  _proto.start = function start(fromValue, onUpdate, onEnd, previousAnimation) {
    this.__active = true;
    this._startPosition = fromValue;
    this._lastPosition = this._startPosition;
    this._onUpdate = onUpdate;
    this.__onEnd = onEnd;
    this._lastTime = Date.now();

    if (previousAnimation instanceof SpringAnimation) {
      var internalState = previousAnimation.getInternalState();
      this._lastPosition = internalState.lastPosition;
      this._lastVelocity = internalState.lastVelocity;
      this._lastTime = internalState.lastTime;
    }

    if (this._initialVelocity !== undefined && this._initialVelocity !== null) this._lastVelocity = this._initialVelocity;
    if (this._delay) this._timeout = setTimeout(this.onUpdate, this._delay);else this.onUpdate();
  };

  _proto.getInternalState = function getInternalState() {
    return {
      lastPosition: this._lastPosition,
      lastVelocity: this._lastVelocity,
      lastTime: this._lastTime
    };
  };

  _proto.stop = function stop() {
    this.__active = false;
    clearTimeout(this._timeout);
    cancelAnimationFrame(this._animationFrame);

    this.__debouncedOnEnd({
      finished: false
    });
  };

  return SpringAnimation;
}(Animation);

var AnimatedStyle =
/*#__PURE__*/
function (_AnimatedWithChildren) {
  _inheritsLoose(AnimatedStyle, _AnimatedWithChildren);

  function AnimatedStyle(style) {
    var _this;

    _this = _AnimatedWithChildren.call(this) || this;
    style = style || {};
    _this._style = style;
    return _this;
  }

  var _proto = AnimatedStyle.prototype;

  _proto.__getValue = function __getValue() {
    var style = {};

    for (var key in this._style) {
      var value = this._style[key];
      if (value instanceof Animated) style[key] = value.__getValue();else style[key] = value;
    }

    return style;
  };

  _proto.__getAnimatedValue = function __getAnimatedValue() {
    var style = {};

    for (var key in this._style) {
      var value = this._style[key];
      if (value instanceof Animated) style[key] = value.__getAnimatedValue();
    }

    return style;
  };

  _proto.__attach = function __attach() {
    for (var key in this._style) {
      var value = this._style[key];
      if (value instanceof Animated) value.__addChild(this);
    }
  };

  _proto.__detach = function __detach() {
    for (var key in this._style) {
      var value = this._style[key];
      if (value instanceof Animated) value.__removeChild(this);
    }
  };

  return AnimatedStyle;
}(AnimatedWithChildren);

var AnimatedProps =
/*#__PURE__*/
function (_Animated) {
  _inheritsLoose(AnimatedProps, _Animated);

  function AnimatedProps(props, callback) {
    var _this;

    _this = _Animated.call(this) || this;

    if (props.style) {
      props = _objectSpread({}, props, {
        style: new AnimatedStyle(props.style)
      });
    }

    _this._props = props;
    _this._callback = callback;

    _this.__attach();

    return _this;
  }

  var _proto = AnimatedProps.prototype;

  _proto.__getValue = function __getValue() {
    var props = {};

    for (var key in this._props) {
      var value = this._props[key];
      if (value instanceof Animated) props[key] = value.__getValue();else props[key] = value;
    }

    return props;
  };

  _proto.__getAnimatedValue = function __getAnimatedValue() {
    var props = {};

    for (var key in this._props) {
      var value = this._props[key];
      if (value instanceof Animated) props[key] = value.__getAnimatedValue();
    }

    return props;
  };

  _proto.__attach = function __attach() {
    for (var key in this._props) {
      var value = this._props[key];
      if (value instanceof Animated) value.__addChild(this);
    }
  };

  _proto.__detach = function __detach() {
    for (var key in this._props) {
      var value = this._props[key];
      if (value instanceof Animated) value.__removeChild(this);
    }
  };

  _proto.update = function update() {
    this._callback();
  };

  return AnimatedProps;
}(Animated);

var Globals = {
  ApplyAnimatedValues: undefined,
  Bugfixes: undefined,
  injectApplyAnimatedValues: function injectApplyAnimatedValues(fn, transform) {
    return Globals.ApplyAnimatedValues = {
      fn: fn,
      transform: transform
    };
  },
  injectBugfixes: function injectBugfixes(fn) {
    return Globals.Bugfixes = fn;
  }
};

function createAnimatedComponent(Component) {
  return (
    /*#__PURE__*/
    function (_React$Component) {
      _inheritsLoose(AnimatedComponent, _React$Component);

      function AnimatedComponent() {
        return _React$Component.apply(this, arguments) || this;
      }

      var _proto = AnimatedComponent.prototype;

      _proto.componentWillUnmount = function componentWillUnmount() {
        this._propsAnimated && this._propsAnimated.__detach();
      };

      _proto.setNativeProps = function setNativeProps(props) {
        var didUpdate = Globals.ApplyAnimatedValues.fn(this.node, props, this);
        if (didUpdate === false) this.forceUpdate();
      };

      _proto.componentWillMount = function componentWillMount() {
        this.attachProps(this.props);
      };

      _proto.attachProps = function attachProps(nextProps) {
        var _this = this;

        var oldPropsAnimated = this._propsAnimated; // The system is best designed when setNativeProps is implemented. It is
        // able to avoid re-rendering and directly set the attributes that
        // changed. However, setNativeProps can only be implemented on leaf
        // native components. If you want to animate a composite component, you
        // need to re-render it. In this case, we have a fallback that uses
        // forceUpdate.

        var callback = function callback() {
          if (_this.node) {
            var didUpdate = Globals.ApplyAnimatedValues.fn(_this.node, _this._propsAnimated.__getAnimatedValue(), _this);
            if (didUpdate === false) _this.forceUpdate();
          }
        };

        this._propsAnimated = new AnimatedProps(nextProps, callback); // When you call detach, it removes the element from the parent list
        // of children. If it goes to 0, then the parent also detaches itself
        // and so on.
        // An optimization is to attach the new elements and THEN detach the old
        // ones instead of detaching and THEN attaching.
        // This way the intermediate state isn't to go to 0 and trigger
        // this expensive recursive detaching to then re-attach everything on
        // the very next operation.

        oldPropsAnimated && oldPropsAnimated.__detach();
      };

      _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        this.attachProps(nextProps);
      };

      _proto.render = function render() {
        var _this2 = this;

        var _propsAnimated$__getV = this._propsAnimated.__getValue(),
            style = _propsAnimated$__getV.style,
            other = _objectWithoutProperties(_propsAnimated$__getV, ["style"]);

        return React.createElement(Component, _extends({}, other, {
          style: Globals.ApplyAnimatedValues.transform(style),
          ref: function ref(node) {
            return _this2.node = node;
          }
        }));
      };

      return AnimatedComponent;
    }(React.Component)
  );
}

var maybeVectorAnim = function maybeVectorAnim(array, _ref, anim, impl) {
  var tension = _ref.tension,
      friction = _ref.friction,
      toValue = _ref.toValue;
  // { tension, friction, toValue: [...]}
  if (array instanceof AnimatedArray) return parallel(array._values.map(function (v, i) {
    return anim(v, {
      tension: tension,
      friction: friction,
      toValue: toValue[i]
    }, impl);
  }), {
    stopTogether: false
  });
  return null;
};

var controller = function controller(value, config, impl) {
  return maybeVectorAnim(value, config, controller, impl) || {
    start: function start(callback) {
      var singleValue = value;
      var singleConfig = config;
      singleValue.stopTracking();
      if (config.toValue instanceof Animated) singleValue.track(new AnimatedTracking(singleValue, config.toValue, impl, singleConfig, callback));else singleValue.animate(new impl(singleConfig), callback);
    },
    stop: function stop() {
      value.stopAnimation();
    }
  };
};

var parallel = function parallel(animations, config) {
  var doneCount = 0;
  var hasEnded = {};
  var stopTogether = !(config && config.stopTogether === false);
  var result = {
    start: function start(callback) {
      if (doneCount === animations.length) return callback && callback({
        finished: true
      });
      animations.forEach(function (animation, idx) {
        var cb = function cb(endResult) {
          hasEnded[idx] = true;
          doneCount++;

          if (doneCount === animations.length) {
            doneCount = 0;
            return callback && callback(endResult);
          }

          if (!endResult.finished && stopTogether) result.stop();
        };

        if (!animation) cb({
          finished: true
        });else animation.start(cb);
      });
    },
    stop: function stop() {
      animations.forEach(function (animation, idx) {
        !hasEnded[idx] && animation.stop();
        hasEnded[idx] = true;
      });
    }
  };
  return result;
};

var template = function template(strings) {
  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    values[_key - 1] = arguments[_key];
  }

  return new AnimatedTemplate(strings, values);
};
var interpolate$1 = function interpolate(parents, config) {
  return new AnimatedInterpolation(parents, config);
};

var check = function check(value) {
  return value === 'auto';
};

var convert = function convert(acc, _ref) {
  var _objectSpread2;

  var name = _ref[0],
      value = _ref[1];
  return _objectSpread({}, acc, (_objectSpread2 = {}, _objectSpread2[name] = new AnimatedValue(value), _objectSpread2));
};

var overwrite = function overwrite(width, height) {
  return function (acc, _ref2) {
    var _objectSpread3;

    var name = _ref2[0],
        value = _ref2[1];
    return _objectSpread({}, acc, (_objectSpread3 = {}, _objectSpread3[name] = value === 'auto' ? name === 'height' ? height : width : value, _objectSpread3));
  };
};

function fixAuto(spring, props) {
  var native = props.native,
      children = props.children,
      from = props.from,
      to = props.to; // Dry-route props back if nothing's using 'auto' in there

  if (!Object.values(from).concat(Object.values(to)).some(check)) return props;
  return new Promise(function (res) {
    var forward = spring.getForwardProps(props);
    var allProps = Object.entries(_objectSpread({}, from, to));
    var portal = document.createElement('div');
    portal.style.cssText = 'position:static;visibility:hidden;';
    document.body.appendChild(portal); // Collect to-state props

    var componentProps = native ? allProps.reduce(convert, forward) : _objectSpread({}, from, to, forward); // Render to-state vdom to portal

    ReactDOM.render(React.createElement("div", {
      ref: function ref(_ref3) {
        if (_ref3) {
          // Once it's rendered out, fetch bounds
          var height = _ref3.clientHeight;
          var width = _ref3.clientWidth; // Remove portal and resolve promise with updated props

          document.body.removeChild(portal);
          res(_objectSpread({}, props, {
            from: Object.entries(from).reduce(overwrite(width, height), from),
            to: Object.entries(to).reduce(overwrite(width, height), to)
          }));
        }
      }
    }, children(componentProps)), portal);
  });
}

var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
  /**
   * @param {string} prefix vendor-specific prefix, eg: Webkit
   * @param {string} key style name, eg: transitionDuration
   * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
   * WebkitTransitionDuration
   */

};

function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}
/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */


var prefixes = ['Webkit', 'Ms', 'Moz', 'O']; // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.

Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

function dangerousStyleValue(name, value, isCustomProperty) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901
  var isEmpty = value == null || typeof value === 'boolean' || value === '';
  if (isEmpty) return '';
  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers

  return ('' + value).trim();
}

function setValueForStyles(node, styles) {
  var style = node.style;

  for (var styleName in styles) {
    if (!styles.hasOwnProperty(styleName)) continue;
    var isCustomProperty = styleName.indexOf('--') === 0;
    var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
    if (styleName === 'float') styleName = 'cssFloat';
    if (isCustomProperty) style.setProperty(styleName, styleValue);else style[styleName] = styleValue;
  }
}

function setValueForAttributes(node, props) {
  var attribute, value;

  for (var name in props) {
    if (name !== 'style') {
      value = props[name];
      attribute = node.getAttribute(name);
      if (attribute) node.setAttribute(name, value);
    }
  }
}

Globals.injectBugfixes(fixAuto);
Globals.injectApplyAnimatedValues(function (instance, props) {
  if (instance.setNativeProps) {
    instance.setNativeProps(props);
  } else if (instance.nodeType && instance.setAttribute !== undefined) {
    setValueForStyles(instance, props.style);
    setValueForAttributes(instance, props);
  } else return false;
}, function (style) {
  return style;
});
var elements = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr', // SVG
'circle', 'clipPath', 'defs', 'ellipse', 'foreignObject', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'text', 'tspan'].reduce(function (acc, element) {
  var _objectSpread2;

  return _objectSpread({}, acc, (_objectSpread2 = {}, _objectSpread2[element] = createAnimatedComponent(element), _objectSpread2));
}, {});

var config = {
  default: {
    tension: 170,
    friction: 26
  },
  gentle: {
    tension: 120,
    friction: 14
  },
  wobbly: {
    tension: 180,
    friction: 12
  },
  stiff: {
    tension: 210,
    friction: 20
  },
  slow: {
    tension: 280,
    friction: 60
  }
};

var Spring =
/*#__PURE__*/
function (_React$PureComponent) {
  _inheritsLoose(Spring, _React$PureComponent);

  function Spring() {
    var _temp, _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return (_temp = _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this, _this.state = {
      props: undefined
    }, _this.defaultAnimation = new AnimatedValue(0), _this.animations = {}, _this.callback = function () {
      if (_this.props.onFrame) _this.props.onFrame(_this.animatedProps.__getValue());
      !_this.props.native && _this.forceUpdate();
    }, _temp) || _assertThisInitialized(_this);
  }

  var _proto = Spring.prototype;

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.stop();
  };

  _proto.componentWillMount = function componentWillMount() {
    this.updatePropsAsync(this.props);
  };

  _proto.componentWillReceiveProps = function componentWillReceiveProps(props) {
    this.updatePropsAsync(props);
  };

  _proto.updatePropsAsync = function updatePropsAsync(props) {
    var _this2 = this;

    if (props.inject) {
      props = props.inject(this, props); // This is in order to not waste time, if it isn't a promise, don't stall

      if (props.then) return props.then(function (props) {
        return _this2.updateProps(props, true);
      });
    }

    this.updateProps(props);
  };

  _proto.updateProps = function updateProps(props, force) {
    var _this3 = this;

    if (force === void 0) {
      force = false;
    }

    var impl = props.impl,
        from = props.from,
        to = props.to,
        config = props.config,
        attach = props.attach,
        immediate = props.immediate,
        reset = props.reset,
        onFrame = props.onFrame,
        onRest = props.onRest;
    var allProps = Object.entries(_objectSpread({}, from, to));
    var defaultAnimationValue = this.defaultAnimation._value;
    this.defaultAnimation.setValue(0);
    this.interpolators = {};
    this.animations = allProps.reduce(function (acc, _ref, i) {
      var _objectSpread2;

      var name = _ref[0],
          value = _ref[1];
      var entry = reset === false && _this3.animations[name] || (_this3.animations[name] = {});
      var isNumber = typeof value === 'number';
      var isArray = !isNumber && Array.isArray(value);
      var fromValue = from[name] !== undefined ? from[name] : value;
      var toValue = isNumber || isArray ? value : 1;

      if (isNumber && attach) {
        // Attach value to target animation
        var target = attach(_this3);
        var targetAnimation = target && target.animations[name];
        if (targetAnimation) toValue = targetAnimation.animation;
      }

      if (isNumber || toValue === 'auto') {
        // Create animated value
        entry.animation = entry.interpolation = entry.animation || new AnimatedValue(fromValue);
      } else if (isArray) {
        // Create animated array
        entry.animation = entry.interpolation = entry.animation || new AnimatedArray(fromValue);
      } else {
        // Deal with interpolations
        var previous = entry.interpolation && entry.interpolation._interpolation(defaultAnimationValue);

        entry.animation = _this3.defaultAnimation;
        entry.interpolation = _this3.defaultAnimation.interpolate({
          range: [0, 1],
          output: [previous !== undefined ? previous : fromValue, value]
        });
      }

      if (immediate && (immediate === true || immediate.indexOf(name) !== -1)) entry.animation.setValue(toValue);
      entry.stopped = false;

      entry.start = function (cb) {
        controller(entry.animation, _objectSpread({
          toValue: toValue
        }, config), impl).start(function (props) {
          if (props.finished) {
            _this3.animations[name].stopped = true;

            if (Object.values(_this3.animations).every(function (animation) {
              return animation.stopped;
            })) {
              var current = _objectSpread({}, _this3.props.from, _this3.props.to);

              onRest && onRest(current);
              cb && cb(current);
            }
          }
        });
      };

      entry.stop = function () {
        entry.stopped = true;
        entry.animation.stopAnimation();
      };

      _this3.interpolators[name] = entry.interpolation;
      return _objectSpread({}, acc, (_objectSpread2 = {}, _objectSpread2[name] = entry, _objectSpread2));
    }, {});
    var oldAnimatedProps = this.animatedProps;
    this.animatedProps = new AnimatedProps(this.interpolators, this.callback);
    oldAnimatedProps && oldAnimatedProps.__detach();
    if (force) this.forceUpdate();
    this.start();
  };

  _proto.start = function start() {
    var _this4 = this;

    return new Promise(function (res) {
      return _this4.getAnimations().forEach(function (animation) {
        return animation.start(res);
      });
    });
  };

  _proto.stop = function stop() {
    this.getAnimations().forEach(function (animation) {
      return animation.stop();
    });
  };

  _proto.getAnimations = function getAnimations() {
    return Object.values(this.animations);
  };

  _proto.getValues = function getValues() {
    return this.animatedProps ? this.animatedProps.__getValue() : {};
  };

  _proto.getAnimatedValues = function getAnimatedValues() {
    return this.props.native ? this.interpolators : this.getValues();
  };

  _proto.getForwardProps = function getForwardProps(props) {
    if (props === void 0) {
      props = this.props;
    }

    var _props = props,
        to = _props.to,
        from = _props.from,
        config = _props.config,
        native = _props.native,
        onRest = _props.onRest,
        onFrame = _props.onFrame,
        children = _props.children,
        render = _props.render,
        reset = _props.reset,
        immediate = _props.immediate,
        impl = _props.impl,
        forward = _objectWithoutProperties(_props, ["to", "from", "config", "native", "onRest", "onFrame", "children", "render", "reset", "immediate", "impl"]);

    return forward;
  };

  _proto.render = function render() {
    var _props2 = this.props,
        children = _props2.children,
        render = _props2.render;
    var values = this.getAnimatedValues();

    if (values && Object.keys(values).length) {
      var animatedProps = _objectSpread({}, this.getAnimatedValues(), this.getForwardProps());

      return render ? render(_objectSpread({}, animatedProps, {
        children: children
      })) : children(animatedProps);
    } else return null;
  };

  return Spring;
}(React.PureComponent);

Spring.defaultProps = {
  from: {},
  to: {},
  config: config.default,
  native: false,
  immediate: false,
  reset: false,
  impl: SpringAnimation,
  inject: Globals.Bugfixes
};

var ref = function ref(object, key) {
  return typeof object === 'function' ? object(key) : object;
};

var Transition =
/*#__PURE__*/
function (_React$PureComponent) {
  _inheritsLoose(Transition, _React$PureComponent);

  function Transition(props) {
    var _this;

    _this = _React$PureComponent.call(this) || this;
    var children = props.children,
        render = props.render,
        keys = props.keys,
        items = props.items,
        _props$from = props.from,
        from = _props$from === void 0 ? {} : _props$from,
        _props$enter = props.enter,
        enter = _props$enter === void 0 ? {} : _props$enter,
        _props$leave = props.leave,
        update = props.update;

    children = render || children || function () {
      return null;
    };

    if (typeof keys === 'function') keys = items.map(keys);

    if (!Array.isArray(children)) {
      children = [children];
      keys = keys ? [keys] : children;
    }

    _this.state = {
      transitionKeys: keys,
      transitions: children.map(function (child, i) {
        var arg = items ? items[i] : keys[i];
        return {
          children: child,
          key: keys[i],
          item: arg,
          to: ref(enter, arg),
          from: ref(from, arg),
          update: ref(update, arg)
        };
      })
    };
    return _this;
  }

  var _proto = Transition.prototype;

  _proto.componentWillReceiveProps = function componentWillReceiveProps(props) {
    var _this2 = this;

    var _state = this.state,
        transitions = _state.transitions,
        transitionKeys = _state.transitionKeys;
    var children = props.children,
        render = props.render,
        keys = props.keys,
        items = props.items,
        _props$from2 = props.from,
        from = _props$from2 === void 0 ? {} : _props$from2,
        _props$enter2 = props.enter,
        enter = _props$enter2 === void 0 ? {} : _props$enter2,
        _props$leave2 = props.leave,
        leave = _props$leave2 === void 0 ? {} : _props$leave2,
        update = props.update;

    children = render || children || function () {
      return null;
    };

    if (typeof keys === 'function') keys = items.map(keys);

    if (!Array.isArray(children)) {
      children = [children];
      keys = keys ? [keys] : children;
    } // Compare next keys with current keys


    var nextSet = new Set(keys);
    var currentSet = new Set(transitionKeys);
    var added = keys.filter(function (item) {
      return !currentSet.has(item);
    });
    var deleted = transitionKeys.filter(function (item) {
      return !nextSet.has(item);
    });
    var rest = keys.filter(function (item) {
      return currentSet.has(item);
    }); // Update child functions

    transitions = transitions.map(function (transition) {
      if (transition.destroy === undefined) {
        var index = keys.indexOf(transition.key);
        var updatedChild = children[index];
        if (updatedChild) transition.children = updatedChild;
        if (update && rest.indexOf(transition.key) !== -1) transition.to = ref(update, items ? items[index] : keys[index]) || transition.to;
      }

      return transition;
    }); // Add new children

    if (added.length) {
      added.forEach(function (key) {
        var index = keys.indexOf(key);
        var child = children[index];
        var arg = items ? items[index] : keys[index];
        var addedChild = {
          children: child,
          key: keys[index],
          item: arg,
          to: ref(enter, arg),
          from: ref(from, arg)
        };
        transitions = transitions.slice(0, index).concat([addedChild], transitions.slice(index));
      });
    } // Remove old children


    if (deleted.length) {
      deleted.forEach(function (key) {
        var oldChild = transitions.find(function (child) {
          return child.key === key;
        });

        if (oldChild) {
          var leavingChild = {
            destroy: true,
            children: oldChild.children,
            key: oldChild.key,
            to: ref(leave, oldChild.item),
            from: ref(from, oldChild.item),
            onRest: function onRest() {
              return _this2.setState(function (state) {
                return {
                  transitions: state.transitions.filter(function (child) {
                    return child !== leavingChild;
                  })
                };
              });
            }
          };
          transitions = transitions.map(function (child) {
            return child === oldChild ? leavingChild : child;
          });
        }
      });
    } // Update transition keys, remove leaving children


    transitionKeys = transitions.filter(function (child) {
      return child.destroy === undefined;
    }).map(function (child) {
      return child.key;
    }); // Re-order list

    var ordered = keys.map(function (key) {
      return transitions.find(function (child) {
        return child.key === key;
      });
    });
    transitions.forEach(function (transition, index) {
      if (transition.destroy && !ordered.find(function (t) {
        return t.key === transition.key;
      })) ordered = ordered.slice(0, index).concat([transition], ordered.slice(index));
    }); // Push new state

    this.setState({
      transitions: ordered,
      transitionKeys: transitionKeys
    });
  };

  _proto.getValues = function getValues() {
    return undefined;
  };

  _proto.render = function render() {
    var _this3 = this;

    var _props = this.props,
        render = _props.render,
        _props$from3 = _props.from,
        _props$enter3 = _props.enter,
        _props$leave3 = _props.leave,
        _props$native = _props.native,
        native = _props$native === void 0 ? false : _props$native,
        _props$config = _props.config,
        config$$1 = _props$config === void 0 ? config.default : _props$config,
        keys = _props.keys,
        items = _props.items,
        onFrame = _props.onFrame,
        onRest = _props.onRest,
        extra = _objectWithoutProperties(_props, ["render", "from", "enter", "leave", "native", "config", "keys", "items", "onFrame", "onRest"]);

    var props = _objectSpread({
      native: native,
      config: config$$1
    }, extra);

    return this.state.transitions.map(function (_ref, i) {
      var key = _ref.key,
          item = _ref.item,
          children = _ref.children,
          rest = _objectWithoutProperties(_ref, ["key", "item", "children"]);

      return React.createElement(Spring, _extends({
        key: key
      }, rest, props, {
        onFrame: onFrame && function (values) {
          return onFrame(item, values);
        },
        render: render && children,
        children: render ? _this3.props.children : children
      }));
    });
  };

  return Transition;
}(React.PureComponent);

var Trail =
/*#__PURE__*/
function (_React$PureComponent) {
  _inheritsLoose(Trail, _React$PureComponent);

  function Trail() {
    return _React$PureComponent.apply(this, arguments) || this;
  }

  var _proto = Trail.prototype;

  _proto.getValues = function getValues() {
    return this.instance && this.instance.getValues();
  };

  _proto.render = function render() {
    var _this = this;

    var _props = this.props,
        children = _props.children,
        render = _props.render,
        _props$from = _props.from,
        from = _props$from === void 0 ? {} : _props$from,
        _props$to = _props.to,
        to = _props$to === void 0 ? {} : _props$to,
        _props$native = _props.native,
        native = _props$native === void 0 ? false : _props$native,
        _props$config = _props.config,
        config$$1 = _props$config === void 0 ? config.default : _props$config,
        keys = _props.keys,
        onRest = _props.onRest,
        extra = _objectWithoutProperties(_props, ["children", "render", "from", "to", "native", "config", "keys", "onRest"]);

    var animations = new Set();

    var hook = function hook(index, animation) {
      animations.add(animation);
      if (index === 0) return undefined;else return Array.from(animations)[index - 1];
    };

    var props = _objectSpread({}, extra, {
      native: native,
      config: config$$1,
      from: from,
      to: to
    });

    var target = render || children;
    return target.map(function (child, i) {
      var attachedHook = function attachedHook(animation) {
        return hook(i, animation);
      };

      return React.createElement(Spring, _extends({
        ref: function ref(_ref) {
          return i === 0 && (_this.instance = _ref);
        },
        onRest: i === 0 ? onRest : null,
        key: keys[i]
      }, props, {
        attach: attachedHook,
        render: render && child,
        children: render ? children : child
      }));
    });
  };

  return Trail;
}(React.PureComponent);

var _createContext = createContext(null),
    Provider = _createContext.Provider,
    Consumer = _createContext.Consumer;

function getScrollType(horizontal) {
  return horizontal ? 'scrollLeft' : 'scrollTop';
}

var ParallaxLayer =
/*#__PURE__*/
function (_React$PureComponent) {
  _inheritsLoose(ParallaxLayer, _React$PureComponent);

  function ParallaxLayer() {
    return _React$PureComponent.apply(this, arguments) || this;
  }

  var _proto = ParallaxLayer.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var parent = this.parent;

    if (parent) {
      parent.layers = parent.layers.concat(this);
      parent.update();
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    var _this = this;

    var parent = this.parent;

    if (parent) {
      parent.layers = parent.layers.filter(function (layer) {
        return layer !== _this;
      });
      parent.update();
    }
  };

  _proto.setPosition = function setPosition(height, scrollTop, immediate) {
    if (immediate === void 0) {
      immediate = false;
    }

    var _parent$props = this.parent.props,
        config$$1 = _parent$props.config,
        impl = _parent$props.impl;
    var targetScroll = Math.floor(this.props.offset) * height;
    var offset = height * this.props.offset + targetScroll * this.props.speed;
    var toValue = parseFloat(-(scrollTop * this.props.speed) + offset);
    if (!immediate) controller(this.animatedTranslate, _objectSpread({
      toValue: toValue
    }, config$$1), impl).start();else this.animatedTranslate.setValue(toValue);
  };

  _proto.setHeight = function setHeight(height, immediate) {
    if (immediate === void 0) {
      immediate = false;
    }

    var _parent$props2 = this.parent.props,
        config$$1 = _parent$props2.config,
        impl = _parent$props2.impl;
    var toValue = parseFloat(height * this.props.factor);
    if (!immediate) controller(this.animatedSpace, _objectSpread({
      toValue: toValue
    }, config$$1), impl).start();else this.animatedSpace.setValue(toValue);
  };

  _proto.initialize = function initialize() {
    var props = this.props;
    var parent = this.parent;
    var targetScroll = Math.floor(props.offset) * parent.space;
    var offset = parent.space * props.offset + targetScroll * props.speed;
    var toValue = parseFloat(-(parent.current * props.speed) + offset);
    this.animatedTranslate = new AnimatedValue(toValue);
    this.animatedSpace = new AnimatedValue(parent.space * props.factor);
  };

  _proto.renderLayer = function renderLayer() {
    var _objectSpread2;

    var _props = this.props,
        style = _props.style,
        children = _props.children,
        offset = _props.offset,
        speed = _props.speed,
        factor = _props.factor,
        className = _props.className,
        props = _objectWithoutProperties(_props, ["style", "children", "offset", "speed", "factor", "className"]);

    var horizontal = this.parent.props.horizontal;
    var translate3d = this.animatedTranslate.interpolate({
      range: [0, 1],
      output: horizontal ? ['translate3d(0px,0,0)', 'translate3d(1px,0,0)'] : ['translate3d(0,0px,0)', 'translate3d(0,1px,0)']
    });
    return React.createElement(elements.div, _extends({}, props, {
      className: className,
      style: _objectSpread((_objectSpread2 = {
        position: 'absolute',
        backgroundSize: 'auto',
        backgroundRepeat: 'no-repeat',
        willChange: 'transform'
      }, _objectSpread2[horizontal ? 'height' : 'width'] = '100%', _objectSpread2[horizontal ? 'width' : 'height'] = this.animatedSpace, _objectSpread2.WebkitTransform = translate3d, _objectSpread2.MsTransform = translate3d, _objectSpread2.transform = translate3d, _objectSpread2), style)
    }), children);
  };

  _proto.render = function render() {
    var _this2 = this;

    return React.createElement(Consumer, null, function (parent) {
      if (parent && !_this2.parent) {
        _this2.parent = parent;

        _this2.initialize();
      }

      return _this2.renderLayer();
    });
  };

  return ParallaxLayer;
}(React.PureComponent);
ParallaxLayer.defaultProps = {
  factor: 1,
  offset: 0,
  speed: 0
};

var Parallax =
/*#__PURE__*/
function (_React$PureComponent2) {
  _inheritsLoose(Parallax, _React$PureComponent2);

  function Parallax() {
    var _temp, _this3;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return (_temp = _this3 = _React$PureComponent2.call.apply(_React$PureComponent2, [this].concat(args)) || this, _this3.state = {
      ready: false
    }, _this3.layers = [], _this3.space = 0, _this3.current = 0, _this3.offset = 0, _this3.busy = false, _this3.moveItems = function () {
      _this3.layers.forEach(function (layer) {
        return layer.setPosition(_this3.space, _this3.current);
      });

      _this3.busy = false;
    }, _this3.scrollerRaf = function () {
      return requestAnimationFrame(_this3.moveItems);
    }, _this3.onScroll = function (event) {
      var horizontal = _this3.props.horizontal;

      if (!_this3.busy) {
        _this3.busy = true;

        _this3.scrollerRaf();

        _this3.current = event.target[getScrollType(horizontal)];
      }
    }, _this3.update = function () {
      var _this3$props = _this3.props,
          scrolling = _this3$props.scrolling,
          horizontal = _this3$props.horizontal;
      var scrollType = getScrollType(horizontal);
      if (!_this3.container) return;
      _this3.space = _this3.container[horizontal ? 'clientWidth' : 'clientHeight'];
      if (scrolling) _this3.current = _this3.container[scrollType];else _this3.container[scrollType] = _this3.current = _this3.offset * _this3.space;
      if (_this3.content) _this3.content.style[horizontal ? 'width' : 'height'] = _this3.space * _this3.props.pages + "px";

      _this3.layers.forEach(function (layer) {
        layer.setHeight(_this3.space, true);
        layer.setPosition(_this3.space, _this3.current, true);
      });
    }, _this3.updateRaf = function () {
      requestAnimationFrame(_this3.update); // Some browsers don't fire on maximize

      setTimeout(_this3.update, 150);
    }, _this3.scrollStop = function (event) {
      return _this3.animatedScroll && _this3.animatedScroll.stopAnimation();
    }, _temp) || _assertThisInitialized(_this3);
  }

  var _proto2 = Parallax.prototype;

  _proto2.scrollTo = function scrollTo(offset) {
    var _props2 = this.props,
        horizontal = _props2.horizontal,
        config$$1 = _props2.config,
        impl = _props2.impl;
    var scrollType = getScrollType(horizontal);
    this.scrollStop();
    this.offset = offset;
    var target = this.container;
    this.animatedScroll = new AnimatedValue(target[scrollType]);
    this.animatedScroll.addListener(function (_ref) {
      var value = _ref.value;
      return target[scrollType] = value;
    });
    controller(this.animatedScroll, _objectSpread({
      toValue: offset * this.space
    }, config$$1), impl).start();
  };

  _proto2.componentDidMount = function componentDidMount() {
    window.addEventListener('resize', this.updateRaf, false);
    this.update();
    this.setState({
      ready: true
    });
  };

  _proto2.componentWillUnmount = function componentWillUnmount() {
    window.removeEventListener('resize', this.updateRaf, false);
  };

  _proto2.componentDidUpdate = function componentDidUpdate() {
    this.update();
  };

  _proto2.render = function render() {
    var _this4 = this,
        _objectSpread3;

    var _props3 = this.props,
        style = _props3.style,
        innerStyle = _props3.innerStyle,
        pages = _props3.pages,
        className = _props3.className,
        scrolling = _props3.scrolling,
        children = _props3.children,
        horizontal = _props3.horizontal;
    var overflow = scrolling ? 'scroll' : 'hidden';
    return React.createElement("div", {
      ref: function ref(node) {
        return _this4.container = node;
      },
      onScroll: this.onScroll,
      onWheel: scrolling ? this.scrollStop : null,
      onTouchStart: scrolling ? this.scrollStop : null,
      style: _objectSpread({
        position: 'absolute',
        width: '100%',
        height: '100%',
        overflow: overflow,
        overflowY: horizontal ? 'hidden' : overflow,
        overflowX: horizontal ? overflow : 'hidden',
        WebkitOverflowScrolling: 'touch',
        WebkitTransform: 'translate(0,0)',
        MsTransform: 'translate(0,0)',
        transform: 'translate3d(0,0,0)'
      }, style),
      className: className
    }, this.state.ready && React.createElement("div", {
      ref: function ref(node) {
        return _this4.content = node;
      },
      style: _objectSpread((_objectSpread3 = {
        position: 'absolute'
      }, _objectSpread3[horizontal ? 'height' : 'width'] = '100%', _objectSpread3.WebkitTransform = 'translate(0,0)', _objectSpread3.MsTransform = 'translate(0,0)', _objectSpread3.transform = 'translate3d(0,0,0)', _objectSpread3.overflow = 'hidden', _objectSpread3[horizontal ? 'width' : 'height'] = this.space * pages, _objectSpread3), innerStyle)
    }, React.createElement(Provider, {
      value: this
    }, children)));
  };

  return Parallax;
}(React.PureComponent);

Parallax.Layer = ParallaxLayer;
Parallax.defaultProps = {
  config: config.slow,
  scrolling: true,
  horizontal: false,
  impl: SpringAnimation
};

var Keyframes =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(Keyframes, _React$Component);

  function Keyframes() {
    var _temp, _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return (_temp = _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this, _this.state = {
      primitive: undefined,
      props: {},
      resolve: function resolve() {
        return null;
      }
    }, _this.next = function (primitive, props) {
      return new Promise(function (resolve) {
        var current = _this.instance && _this.instance.getValues();

        var from = typeof props.from === 'function' ? props.from : _objectSpread({}, _this.state.props.from, current, props.from);

        _this.setState(function (state) {
          return {
            primitive: primitive,
            props: _objectSpread({}, props, {
              from: from
            }),
            resolve: resolve
          };
        });
      });
    }, _temp) || _assertThisInitialized(_this);
  }

  var _proto = Keyframes.prototype;

  _proto.componentDidMount = function componentDidMount() {
    if (this.props.script) this.props.script(this.next);
  };

  _proto.render = function render() {
    var _this2 = this;

    var _state = this.state,
        Component = _state.primitive,
        props = _state.props,
        resolve = _state.resolve;

    var _props = this.props,
        script = _props.script,
        rest = _objectWithoutProperties(_props, ["script"]);

    return Component ? React.createElement(Component, _extends({
      ref: function ref(_ref) {
        return _this2.instance = _ref;
      }
    }, rest, props, {
      onRest: resolve
    })) : null;
  };

  return Keyframes;
}(React.Component);

exports.Spring = Spring;
exports.Keyframes = Keyframes;
exports.Transition = Transition;
exports.Trail = Trail;
exports.Parallax = Parallax;
exports.ParallaxLayer = ParallaxLayer;
exports.config = config;
exports.template = template;
exports.animated = elements;
exports.interpolate = interpolate$1;
exports.Animation = Animation;
exports.Value = AnimatedValue;
